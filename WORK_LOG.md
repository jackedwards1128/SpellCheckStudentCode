Name: YOUR NAME HERE

| Date    |      Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Update |
|:--------|:--------------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept 25 | 5:20 - 6:00 pm | I was sick and therefore missed the thinking class, but all the time laying in my bed gave me plenty of room to think. I'm essentially just going to think while writing this work log so all my thoughts come through. I'm basically thinking that we need something equivalent to a map, such that we can essentially look up a word based on something ingrained within it. In moksha patam, you could look up where a node leads by using the value of the tile its on (something innate to itself). The obvious conclusion to draw from these thoughts is that the innate "thing" that can be utilized from a word to look it up is its letters. My first thought as to how you could use its letters to look up the word's existence in the dictionary was by essentially creating a super long array where the index is some sort of numerical representation of the letters. I.e, a bunch of numbers 1-26 stacked side by side. That was until I realized that super long words push the limits of the boundary of the array. Since that one word about lung disease from volcanos or whatever is 45 letters long, the array's index would need to go up to a number with 90 digits, uh oh. So that idea didn't logically pan out. But now, I have a good idea! Basically, I'm think of creating a tree like structure. Each node in the tree represents a string of letters with all the letters of the nodes prior to it. So if you start at the root node, and then go to one of its 26 children--specifically the 'c' node, and then 'a', and then 't', you reach the node representing the word 'cat'. Now, the glaring problem with this data structure is the nature of strings of characters that are merely interim non-words that approach a real word. For example, the node for the word 'outlet' would have to be proceeded by a node that represented the string 'outle', which is not a word, and yet it is a node. Since we do not want a node for every possible permuatation of the alphabet for 45 letters, we will include these interim words, but somehow ingrain within them that they aren't real. This tree would be 143,000 nodes large, but we have to also estimate the amount of interim words. While the average characters-per-word of real English text is 5.1 characters, this is a dictionary, which has an average of approximately 8 characters per word according to an analysis of the unix word list. This means there will be (on average) 7 nodes preceeding each word, and therefore approximately 7*143,000 interim words, which makes the overall total 1.14 million nodes. In a perfectly optimized implementation, each node would only need to contain the data of the letter it represents and whether or not it is a real word (7 bits <1-32> + 1 bit <exist or not> = 1 byte) and its children (1-26 * 8 bytes <memory address> = up to 208 bytes). Clearly, the bottle neck here is the need for a node to contain pointers to its children. |
|         |  6:00 - 6:45   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Okay, I obviously cannot encode pointers to the children of a node within itself, because that would use way too much data. So instead, I must encode something within the node that can allow the searching algorithm to find the correct child of a node in a way that does not scale with the length of the dictionary. My initial thought was to store the amount of children within each node, as if you just arranged every single node in depth-first-order, you would be able to parse for the string you wanted. However, since you would be required to go through other chains to find the desired chain, this algorithm would scale with the length of the dictionary, and is therefore unacceptable. I need to somehow encode information within a city that would help a searcher find the children of a node without having to look through unrelated nodes. Okay, I think I have a good idea! My thought is to arrange the data in a breadth-first manner. Basically, you have siblings next to each other, and then once you finish the siblings, you have all of the children of the first of the original siblings, and then all of the children of the second of the original siblings, etc. Then, within each node, you store how many spaces you need to jump forward to go from that node to it's first child. At that point, you can just find the letter you're looking for in under 26 checks. Hypothetically, if you were at an 'Z' node, and it had 25 siblings, and all of those siblings (and the Z) had 26 children, then you would need to move 26*25=650 spaces forward to reach the first child of the original 'Z' node. 650 is small enough to be represented by only 10 bits!! This means each node needs only 18 bits. 1.14 million * 18 = 20,520,000 bits = 2,565,000 bytes = 2.5ish megabytes!! Now, 18 bits is kind of a weird way to subdivide the dataset by, so i'll round up to 24 so it can be 3 bytes/node. |


To add a new row to the table, click into a cell and then hit shift-enter. 