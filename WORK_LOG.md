Name: YOUR NAME HERE

| Date    |          Time          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Update |
|:--------|:----------------------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept 25 |     5:20 - 6:00 pm     | I was sick and therefore missed the thinking class, but all the time laying in my bed gave me plenty of room to think. I'm essentially just going to think while writing this work log so all my thoughts come through. I'm basically thinking that we need something equivalent to a map, such that we can essentially look up a word based on something ingrained within it. In moksha patam, you could look up where a node leads by using the value of the tile its on (something innate to itself). The obvious conclusion to draw from these thoughts is that the innate "thing" that can be utilized from a word to look it up is its letters. My first thought as to how you could use its letters to look up the word's existence in the dictionary was by essentially creating a super long array where the index is some sort of numerical representation of the letters. I.e, a bunch of numbers 1-26 stacked side by side. That was until I realized that super long words push the limits of the boundary of the array. Since that one word about lung disease from volcanos or whatever is 45 letters long, the array's index would need to go up to a number with 90 digits, uh oh. So that idea didn't logically pan out. But now, I have a good idea! Basically, I'm think of creating a tree like structure. Each node in the tree represents a string of letters with all the letters of the nodes prior to it. So if you start at the root node, and then go to one of its 26 children--specifically the 'c' node, and then 'a', and then 't', you reach the node representing the word 'cat'. Now, the glaring problem with this data structure is the nature of strings of characters that are merely interim non-words that approach a real word. For example, the node for the word 'outlet' would have to be proceeded by a node that represented the string 'outle', which is not a word, and yet it is a node. Since we do not want a node for every possible permuatation of the alphabet for 45 letters, we will include these interim words, but somehow ingrain within them that they aren't real. This tree would be 143,000 nodes large, but we have to also estimate the amount of interim words. While the average characters-per-word of real English text is 5.1 characters, this is a dictionary, which has an average of approximately 8 characters per word according to an analysis of the unix word list. This means there will be (on average) 7 nodes preceeding each word, and therefore approximately 7*143,000 interim words, which makes the overall total 1.14 million nodes. In a perfectly optimized implementation, each node would only need to contain the data of the letter it represents and whether or not it is a real word (7 bits <1-32> + 1 bit <exist or not> = 1 byte) and its children (1-26 * 8 bytes <memory address> = up to 208 bytes). Clearly, the bottle neck here is the need for a node to contain pointers to its children. |
|         |      6:00 - 6:45       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Okay, I obviously cannot encode pointers to the children of a node within itself, because that would use way too much data. So instead, I must encode something within the node that can allow the searching algorithm to find the correct child of a node in a way that does not scale with the length of the dictionary. My initial thought was to store the amount of children within each node, as if you just arranged every single node in depth-first-order, you would be able to parse for the string you wanted. However, since you would be required to go through other chains to find the desired chain, this algorithm would scale with the length of the dictionary, and is therefore unacceptable. I need to somehow encode information within a city that would help a searcher find the children of a node without having to look through unrelated nodes. Okay, I think I have a good idea! My thought is to arrange the data in a breadth-first manner. Basically, you have siblings next to each other, and then once you finish the siblings, you have all of the children of the first of the original siblings, and then all of the children of the second of the original siblings, etc. Then, within each node, you store how many spaces you need to jump forward to go from that node to it's first child. At that point, you can just find the letter you're looking for in under 26 checks. Hypothetically, if you were at an 'Z' node, and it had 25 siblings, and all of those siblings (and the Z) had 26 children, then you would need to move 26*25=650 spaces forward to reach the first child of the original 'Z' node. 650 is small enough to be represented by only 10 bits!! This means each node needs only 18 bits. 1.14 million * 18 = 20,520,000 bits = 2,565,000 bytes = 2.5ish megabytes!! Now, 18 bits is kind of a weird way to subdivide the dataset by, so i'll round up to 24 so it can be 3 bytes/node. |
| Sept 26 | A Block; 35ish minutes |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            I discussed my plan with Mr. Millstein. He was very encouraging of my idea, as he said I was very much on track to the solution. I bounced off the various facets of my solution with him, but he couldn't give me much input because he didn't want to spoil anything for me. A lot of this time was essentially like speaking to the duck in CS1 (doesn't have to say anything back, but hearing yourself explain things helps catch leaps in logic). This made me realize some problems with my ideas. The first of which is the issue of ingraining how many "spaces" the searcher must jump forward to reach the first child of a node. If this was implemented it would be GREAT, the issue is that it is indeed a pain to implement. As you are constructing the array out of the dictionary, how do you know in advance how many children/siblings a node will have, until you've gone through the whole dictionary? |
| Sept 28 |    7:30 - 7:45  pm     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        After diving into IntelliJ and trying to code, I ran directly into the problem described above. Indeed, how could you know how many spots you'd need to jump forward? You'd almost need to make two trees, the first being sloppy and expensive with pointers to siblings/children, the second being a refined tree with the information described in my original theory. Hmmm this is sounding like a good idea! I need to somehow figure out how to store the refined dictionary in a text file form though, as having to construct this dictionary every compile would be an obvious source of added runtime. |
|         |         8:10pm         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           YES!!! I made the large dictionary where each node is a node class that has a char for the letter, boolean for validity, and 2 pointers to first_child and next_sibling. You can just follow the chain of next_siblings to reach any child of a given node. Anyway, I made it and then I used the debugger and followed all the children and siblings down to see that J-A-C-K is a valid word!! Tear-jerking levels of proud to be named after a valid word. |
|         |         8:40pm         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Okay, I've built a searching algorithm off of the inefficient tree and it like half works. I'm pretty sure it flags every non-word in jabberwocky, but for some reason it has loads of duplicates even though I have a if (!contains) thrown in there. The more concerning issue, however, is that 'thought', 'awhile', 'through', 'snack', and a couple otheer real words are flagged as non words. I followed the tree for 'thought', and the tree believes 'though' and 'thought' and 'thoughtftul' etc are not valid. This is where I'll need to pick up. I feel pretty good about where I'm at, though |
|         |         9:10pm         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Okay I fixed some bugs in regards to creating the array of the string and duplicates and stuff. I spent a lot of time looking for the other bug, which turned out to be that if there was no child and it had to create one, it woulnd't actually take on the node of that child and instead was still the parent before. Once I fixed that and the duplicates problem, it all worked. However, i'm currently using an arraylist and then i go back and remove duplicates after the fact. For shakespeare, if i take out the duplicate removing part of my code, i have a runtime of 865ms!!! That feels really good. However, my duplicate remover adds like 600ms to that total, so i gotta do better. |
|         |         9:45pm         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   YEAHHHHH IT WORKS!!! Many say that Rome wasn't built in a day. They were right, because it was built in 986 milliseconds by Jedwards. Anyway, through trying to solve it I ran into the problem that trying to add mispelled words to an array/arraylist and then cut off the duplicates afterwards was just not going to cut it. So then I knew I had to use something like a HashSet which I saw during code review when I saw Beesley's highways/hospital code during the debrief. Anyway, I did that but then it was unfortuante because the problem set requires that you have everything in order, and I guess hashsets don't work like that (there is no order in a hashset). So what I did instead was have an arraylist collecting words, but also a hashset, and then whenever a word was flagged, it would check if it was in the hashset, and if not, it would add it to BOTH the arraylist and the hashset. Then I just had to convert the arraylist into an array and return it, and it worked! Huzzah. |
| Oct 2   |  Tutorial (10am ish)   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Fortunately, I already coded a Trie prior to the theory session on Tries, I just didn't know it was called a trie instead of a tree (I too agree with Mr. Blick's dissatisfaction with the nomenclature). Anyway, that made it pretty easy to code the new version of a Trie (the one with a map that has 26 children). I knew that both apostrophes and hyphens would be a problem, and I figured that I couldn't bunch both of those into one index, as I figured there are Strings of characters where at a given point either a hyphen or apostrophe could lead to a valid word. Since these would have to coexist, apostrophes and hyphens must have different requirements. However, other characters like numbers also exist. It feels foolish to make an index in children for all the numbers and other characters. I figured that I can group all of these characters with hyphens as "miscellaneous" characters, and all characters other than a-z and apostrophes would just go into index 27. And it worked! Hurray. I find it interesting that this Trie isn't much faster than the Trie with linear-search lookups for each child. My though is that it has to do with the fact that in my old Trie, each node had only 2 pointers, or 16 btyes. This contrasts with the nodes now, which have 28 pointers, or 224 bytes! I think the computer having to deal with all that extra data slows it down, even if the algorithm's time complexity technically decreases. |


To add a new row to the table, click into a cell and then hit shift-enter. 